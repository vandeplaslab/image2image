"""Guess dialog."""

from __future__ import annotations

import typing as ty

import numpy as np
from loguru import logger
from napari.layers.points.points import Mode
from qtextra import helpers as hp
from qtextra.utils.utilities import connect
from qtextra.widgets.qt_dialog import QtFramelessTool
from qtpy.QtCore import Qt  # type: ignore[attr-defined]
from qtpy.QtWidgets import QFormLayout

if ty.TYPE_CHECKING:
    from image2image.qt.dialog_register import ImageRegistrationWindow


logger = logger.bind(src="InitialTransformDialog")


def distance2line(p1: ty.Sequence[int], p2: ty.Sequence[int], p3: ty.Sequence[int]) -> float:
    """
    Returns the distance of the point `p3` to the line passing through `p1` and `p2`.
    Args:
        `p1`: The first point on the line
        `p2`: The second point on the line
        `p3`: The point to compute its distance to the line

    Returns:
        The distance of `p3` to the line
    """
    dist = np.abs((p2[0] - p1[0]) * (p1[1] - p3[1]) - (p1[0] - p3[0]) * (p2[1] - p1[1]))
    dist = dist / np.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]))
    return dist


def simplify_contour(contours: list[np.ndarray], d: float) -> list[np.ndarray]:
    """
    Given a contour as a sequence of points, it returns a simplified version based on the distance parameter `d`.
    Larger valued of `d` results in simpler contours but less similar to the original contour.
    Args:
        `contours`: a sequence of contours generated by opencv
        `d`: the tuning parameter for the amount of simplification

    Returns:
        A sequence of simplified contours
    """

    simp = []
    for contour in contours:
        left = 0
        right = 2
        res = [contour[0]]

        while right < len(contour):
            p1 = contour[left][0]
            p2 = contour[right][0]
            p3 = contour[right - 1][0]
            dist = distance2line(p1, p2, p3)
            if dist > d:
                left = right - 1
                res.append(contour[left])
            right += 1
        simp.append(np.array(res))
    return simp


def find_contours(image: np.ndarray) -> list[np.ndarray]:
    """Find contours in image."""
    import cv2

    if hasattr(image, "compute"):
        image = image.compute()
    # pre-process image
    image = np.nan_to_num(image, nan=0)
    image = cv2.normalize(image, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
    image[image > 1] = 255

    # detect contours and filter
    contours, _ = cv2.findContours(image, mode=cv2.RETR_TREE, method=cv2.CHAIN_APPROX_SIMPLE)
    return contours


def contour_formatter(contours: list[np.ndarray]) -> list[str]:
    """Format contours."""
    from natsort import index_natsorted, order_by_index

    # create options
    options = [f"Contour {i} ({len(c)} points)" for (i, c) in enumerate(contours)]
    # sort by the number of points
    indices = index_natsorted([len(c) for c in contours], reverse=True)
    options = order_by_index(options, indices)
    return options


def contour_to_points(contour: np.ndarray) -> np.ndarray:
    """Convert contour to points."""
    return np.squeeze(contour)


def filter_contours(contours: list[np.ndarray], n_min: int = 2) -> list[np.ndarray]:
    """Filter contours."""
    return [c for c in contours if len(c) >= n_min]


class GuessDialog(QtFramelessTool):
    """Dialog to pre-process moving image."""

    contours: list[np.ndarray] | None = None
    simplified_contours: list[np.ndarray] | None = None
    current_index: int = -1
    current_contour: np.ndarray = None
    current_transformed_contour: np.ndarray = None

    def __init__(self, parent: ImageRegistrationWindow):
        super().__init__(parent)
        self.on_detect()
        connect(parent.temporary_fixed_points_layer.events.data, self.on_point_added, state=True)

    def on_detect(self) -> None:
        """Detect fiducials."""
        parent: ImageRegistrationWindow = self.parent()  # type: ignore[assignment]
        reader = parent.get_current_moving_reader()
        if reader is None:
            return
        # get image and detect contours
        image = reader.get_channel(0)
        if image is not None:
            self.contours = find_contours(image)
            logger.trace(f"Found {len(self.contours)} contours...")
            self.on_update_region_choices()

    def on_update_region_choices(self) -> None:
        """Detect fiducials."""
        # update available contours
        self.simplified_contours = filter_contours(simplify_contour(self.contours, self.distance.value()))

        options = contour_formatter(self.simplified_contours)
        hp.combobox_setter(self.region_choice, clear=True, items=options)
        self.on_region_change()

    def on_region_change(self) -> None:
        """Update region."""
        current = self.region_choice.currentText()
        contour_index = int(current.split(" ")[1])
        logger.trace(f"Selected contour {contour_index}...")
        parent: ImageRegistrationWindow = self.parent()  # type: ignore[assignment]
        # add contour to the moving image
        contour = contour_to_points(self.simplified_contours[contour_index])
        contour = contour[:, [1, 0]]
        contour = parent.transform_model.apply_moving_initial_transform(contour, inverse=False)
        self.current_contour = parent.temporary_moving_points_layer.data = contour
        # select the top left point
        point_index = -1  # self.contour_index.value()
        if point_index == -1:
            point_index = np.argmin(contour[:, 0] + contour[:, 1])
        self.current_index = point_index
        # update size
        sizes = parent.temporary_moving_points_layer.size
        min_size = np.min(sizes)
        sizes = np.full_like(sizes, min_size)
        sizes[point_index] = min_size * 2
        parent.temporary_moving_points_layer.size = sizes
        # update color so it's easier to see which point they are trying to edit
        colors = ["green"] * len(contour)
        colors[point_index] = "red"
        parent.temporary_moving_points_layer.edge_color = colors

    def on_select(self) -> None:
        """Detect fiducials."""
        current = self.region_choice.currentText()
        index = int(current.split(" ")[1])
        logger.trace(f"Selected contour {index}...")
        parent: ImageRegistrationWindow = self.parent()  # type: ignore[assignment]
        parent.temporary_fixed_points_layer.mode = Mode.ADD
        parent.view_fixed.select_one_layer(parent.temporary_fixed_points_layer)

    def on_point_added(self, _evt: ty.Any) -> None:
        """Point was added."""
        parent: ImageRegistrationWindow = self.parent()  # type: ignore[assignment]
        moving_reader = parent.get_current_moving_reader()
        fixed_reader = parent.get_current_fixed_reader()
        if not moving_reader or not fixed_reader:
            logger.warning("No moving or fixed image loaded...")
            return
        data = parent.temporary_fixed_points_layer.data
        if len(data) == 0:  # or len(data) > 1:
            logger.warning("You need to add exactly one point in the fixed image...")
            return
        # get the first point from the fixed layer
        # points are in the physical space (in um) so let's convert it to pixel space
        fixed_point = data[-1] * fixed_reader.resolution
        # get the corresponding point in the moving image
        # points are in the physical space (in um) so let's convert it to pixel space
        moving_point = self.current_contour[self.current_index] * moving_reader.resolution
        # transform the moving contour from um to pixel space
        contours = np.copy(self.current_contour) * moving_reader.resolution
        # subtract the moving point (normalize coordinates)
        contours -= moving_point
        # add the fixed point so it's origin is corrected
        contours += fixed_point
        # transform the points to the original space
        contours = contours * fixed_reader.inv_resolution
        self.current_transformed_contour = contours
        with parent.temporary_fixed_points_layer.events.data.blocker():
            parent.temporary_fixed_points_layer.data = contours

    def accept(self) -> None:
        """Accept changes."""
        if self.current_contour is None or self.current_transformed_contour is None:
            hp.warn(self, "No contour selected...")
            return None
        parent: ImageRegistrationWindow = self.parent()  # type: ignore[assignment]
        parent.view_moving.remove_layer(parent.temporary_moving_points_layer.name)
        parent.view_fixed.remove_layer(parent.temporary_fixed_points_layer.name)
        parent._update_layer_points(parent.moving_points_layer, self.current_contour, block=False)
        parent._update_layer_points(parent.fixed_points_layer, self.current_transformed_contour, block=False)
        parent.on_update_text(block=True)
        hp.disable_widgets(parent.guess_btn, disabled=False)
        return super().accept()

    def reject(self) -> None:
        """Reject changes."""
        parent: ImageRegistrationWindow = self.parent()  # type: ignore[assignment]
        parent.view_moving.remove_layer(parent.temporary_moving_points_layer.name)
        parent.view_fixed.remove_layer(parent.temporary_fixed_points_layer.name)
        hp.disable_widgets(parent.guess_btn, disabled=False)
        return super().reject()

    # noinspection PyAttributeOutsideInit
    def make_panel(self) -> QFormLayout:
        """Make panel."""

        _, header_layout = self._make_close_handle(title="Find fiducials...")

        self.detect_btn = hp.make_btn(
            self, "Find fiducials", func=self.on_detect, tooltip="Find fiducial markers in the moving image."
        )
        self.distance = hp.make_double_spin_box(
            self,
            minimum=0.1,
            maximum=10,
            value=2,
            step_size=0.25,
            n_decimals=2,
            tooltip="Distance to simplify contours.",
            func=self.on_update_region_choices,
        )
        self.region_choice = hp.make_combobox(self, func=self.on_region_change, tooltip="Select region of interest.")

        self.select_btn = hp.make_btn(
            self, "Select point in fixed image", func=self.on_select, tooltip="Select a point in the fixed image."
        )

        layout = hp.make_form_layout(self)
        hp.style_form_layout(layout)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.addRow(header_layout)
        layout.addRow(
            hp.make_label(
                self,
                "You can try to to automatically find fiducial markers in the <b>moving</b> image.<br><br>"
                "1. Click on the <b>Find fiducials</b> button.<br>"
                "2. Specify how many fiducials you wish to retain.<br>"
                "3. Click in the <b>fixed</b> image to place the <b>first</b> fiducial marker. Make sure this matches"
                " exactly the fiducial marker in the <b>moving</b> image.<br>"
                "4. Click on <b>OK</b> to continue.<br><br>"
                "At this point you might be satisfied, however, it's advised to manually check <b>each</b> fiducial"
                " marker to ensure they are correctly placed.",
                wrap=True,
                alignment=Qt.AlignmentFlag.AlignLeft,
            )
        )
        layout.addRow(self.detect_btn)
        layout.addRow("Simplify contours", self.distance)
        layout.addRow("Region", self.region_choice)
        layout.addRow(self.select_btn)

        layout.addRow(
            hp.make_h_layout(
                hp.make_btn(self, "OK", func=self.accept),
                hp.make_btn(self, "Cancel", func=self.reject),
            )
        )
        return layout
